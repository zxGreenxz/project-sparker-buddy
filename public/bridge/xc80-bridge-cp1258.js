/**
 * XC80 Print Bridge Server v7.0 - PDF SUPPORT
 * H·ªó tr·ª£ CP1258 (Windows-1258) cho ti·∫øng Vi·ªát c√≥ d·∫•u
 * H·ªó tr·ª£ in BITMAP t·ª´ canvas
 * H·ªó tr·ª£ in PDF tr·∫Øng ƒëen
 *
 * C√°ch ch·∫°y:
 * npm install express body-parser cors iconv-lite pdf-poppler sharp
 * node xc80-bridge-pdf-support.js
 */

const express = require("express");
const bodyParser = require("body-parser");
const cors = require("cors");
const net = require("net");
const iconv = require("iconv-lite");
const fs = require("fs");
const path = require("path");
const { promisify } = require("util");
const { exec } = require("child_process");
const execAsync = promisify(exec);

// Th∆∞ vi·ªán x·ª≠ l√Ω h√¨nh ·∫£nh
const sharp = require("sharp");

const app = express();
const PORT = 9100;
const TEMP_DIR = path.join(__dirname, "temp");

// T·∫°o th∆∞ m·ª•c temp n·∫øu ch∆∞a c√≥
if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR, { recursive: true });
}

// Middleware
app.use(cors());
app.use(bodyParser.json({ limit: "50mb" }));
app.use(bodyParser.raw({ type: "application/octet-stream", limit: "50mb" }));

// ESC/POS Constants
const ESC = "\x1B";
const GS = "\x1D";

/**
 * CP1258 Encoding Map (Unicode ‚Üí Windows-1258)
 */
const CP1258_MAP = {
  // Lowercase vowels
  √†: "\xE0", √°: "\xE1", ·∫£: "\xE3", √£: "\xE3", ·∫°: "\xE1",
  ·∫±: "\xE0", ·∫Ø: "\xE1", ·∫≥: "\xE3", ·∫µ: "\xE3", ·∫∑: "\xE1",
  √®: "\xE8", √©: "\xE9", ·∫ª: "\xEB", ·∫Ω: "\xEB", ·∫π: "\xE9",
  ·ªÅ: "\xE8", ·∫ø: "\xE9", ·ªÉ: "\xEB", ·ªÖ: "\xEB", ·ªá: "\xE9",
  √¨: "\xEC", √≠: "\xED", ·ªâ: "\xEF", ƒ©: "\xEF", ·ªã: "\xED",
  √≤: "\xF2", √≥: "\xF3", ·ªè: "\xF5", √µ: "\xF5", ·ªç: "\xF3",
  ·ªì: "\xF2", ·ªë: "\xF3", ·ªï: "\xF5", ·ªó: "\xF5", ·ªô: "\xF3",
  ·ªù: "\xF2", ·ªõ: "\xF3", ·ªü: "\xF5", ·ª°: "\xF5", ·ª£: "\xF3",
  √π: "\xF9", √∫: "\xFA", ·ªß: "\xFC", ≈©: "\xFC", ·ª•: "\xFA",
  ·ª´: "\xF9", ·ª©: "\xFA", ·ª≠: "\xFC", ·ªØ: "\xFC", ·ª±: "\xFA",
  ·ª≥: "\xFD", √Ω: "\xFD", ·ª∑: "\xFF", ·ªπ: "\xFF", ·ªµ: "\xFD",
  ƒë: "\xF0", ƒê: "\xD0",
  // Uppercase vowels
  √Ä: "\xC0", √Å: "\xC1", ·∫¢: "\xC3", √É: "\xC3", ·∫†: "\xC1",
  √à: "\xC8", √â: "\xC9", ·∫∫: "\xCB", ·∫º: "\xCB", ·∫∏: "\xC9",
  √å: "\xCC", √ç: "\xCD", ·ªà: "\xCF", ƒ®: "\xCF", ·ªä: "\xCD",
  √í: "\xD2", √ì: "\xD3", ·ªé: "\xD5", √ï: "\xD5", ·ªå: "\xD3",
  √ô: "\xD9", √ö: "\xDA", ·ª¶: "\xDC", ≈®: "\xDC", ·ª§: "\xDA",
  ·ª≤: "\xDD", √ù: "\xDD", ·ª∂: "\xDF", ·ª∏: "\xDF", ·ª¥: "\xDD",
};

/**
 * Chuy·ªÉn Unicode sang CP1258
 */
function convertToCP1258(text) {
  let result = "";
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    result += CP1258_MAP[char] || char;
  }
  return result;
}

/**
 * Convert PDF th√†nh h√¨nh ·∫£nh PNG s·ª≠ d·ª•ng pdftoppm
 */
async function convertPdfToImage(pdfBuffer, dpi = 203) {
  const timestamp = Date.now();
  const pdfPath = path.join(TEMP_DIR, `temp_${timestamp}.pdf`);
  const outputPrefix = path.join(TEMP_DIR, `output_${timestamp}`);

  try {
    // L∆∞u PDF buffer v√†o file
    fs.writeFileSync(pdfPath, pdfBuffer);

    // Convert PDF sang PNG v·ªõi pdftoppm (grayscale)
    // -png: output PNG
    // -gray: grayscale mode
    // -r: resolution (DPI)
    // -singlefile: ch·ªâ convert page ƒë·∫ßu ti√™n
    const command = `pdftoppm -png -gray -r ${dpi} -singlefile "${pdfPath}" "${outputPrefix}"`;
    
    await execAsync(command);

    // ƒê·ªçc file PNG v·ª´a t·∫°o
    const pngPath = `${outputPrefix}.png`;
    const imageBuffer = fs.readFileSync(pngPath);

    // Cleanup temp files
    fs.unlinkSync(pdfPath);
    fs.unlinkSync(pngPath);

    return imageBuffer;
  } catch (error) {
    // Cleanup on error
    try {
      if (fs.existsSync(pdfPath)) fs.unlinkSync(pdfPath);
    } catch (e) {}
    throw error;
  }
}

/**
 * Convert h√¨nh ·∫£nh th√†nh monochrome bitmap cho thermal printer
 */
async function convertToMonochrome(imageBuffer, width = 576, threshold = 128) {
  try {
    // Resize v√† convert sang grayscale
    let image = sharp(imageBuffer);
    const metadata = await image.metadata();

    // Resize ƒë·ªÉ fit v·ªõi ƒë·ªô r·ªông m√°y in (576px cho 80mm @ 203dpi)
    if (metadata.width > width) {
      image = image.resize(width, null, {
        fit: "inside",
        withoutEnlargement: false,
      });
    }

    // Convert sang grayscale v√† threshold ƒë·ªÉ t·∫°o ·∫£nh ƒëen tr·∫Øng
    const processedBuffer = await image
      .grayscale()
      .threshold(threshold)
      .raw()
      .toBuffer({ resolveWithObject: true });

    return {
      data: processedBuffer.data,
      width: processedBuffer.info.width,
      height: processedBuffer.info.height,
    };
  } catch (error) {
    throw new Error(`Image processing error: ${error.message}`);
  }
}

/**
 * T·∫°o ESC/POS bitmap commands t·ª´ monochrome image data
 */
function createBitmapCommands(imageData, width, height) {
  const commands = [];

  // ESC @ - Initialize printer
  commands.push(Buffer.from([0x1B, 0x40]));

  // Chia h√¨nh ·∫£nh th√†nh c√°c d·∫£i 24 pixel height
  const sliceHeight = 24;
  const numSlices = Math.ceil(height / sliceHeight);

  for (let slice = 0; slice < numSlices; slice++) {
    const startY = slice * sliceHeight;
    const endY = Math.min(startY + sliceHeight, height);
    const actualHeight = endY - startY;

    // ESC * m nL nH d1...dk
    // m = 33 (24-dot double-density)
    const nL = width & 0xff;
    const nH = (width >> 8) & 0xff;

    const header = Buffer.from([0x1B, 0x2A, 0x21, nL, nH]);
    commands.push(header);

    // T·∫°o bitmap data cho slice n√†y
    const sliceData = [];
    for (let x = 0; x < width; x++) {
      // M·ªói c·ªôt c√≥ 3 bytes (24 bits)
      const bytes = [0, 0, 0];

      for (let y = 0; y < sliceHeight; y++) {
        const actualY = startY + y;
        if (actualY >= height) break;

        const pixelIndex = actualY * width + x;
        const pixelValue = imageData[pixelIndex];

        // N·∫øu pixel ƒëen (0), set bit t∆∞∆°ng ·ª©ng
        if (pixelValue === 0) {
          const byteIndex = Math.floor(y / 8);
          const bitIndex = y % 8;
          bytes[byteIndex] |= 1 << (7 - bitIndex);
        }
      }

      sliceData.push(...bytes);
    }

    commands.push(Buffer.from(sliceData));

    // Line feed
    commands.push(Buffer.from([0x0A]));
  }

  // Feed th√™m gi·∫•y v√† cut
  commands.push(Buffer.from([0x1B, 0x64, 0x03])); // Feed 3 lines
  commands.push(Buffer.from([0x1D, 0x56, 0x00])); // Full cut

  return Buffer.concat(commands);
}

/**
 * G·ª≠i data ƒë·∫øn m√°y in qua network
 */
async function sendToPrinter(printerIp, printerPort, data) {
  return new Promise((resolve, reject) => {
    const client = net.createConnection(
      {
        host: printerIp,
        port: printerPort,
        timeout: 10000,
      },
      () => {
        client.write(data, (err) => {
          if (err) {
            reject(err);
          } else {
            setTimeout(() => {
              client.end();
              resolve();
            }, 500);
          }
        });
      }
    );

    client.on("timeout", () => {
      client.destroy();
      reject(new Error("Connection timeout"));
    });

    client.on("error", (err) => {
      reject(err);
    });
  });
}

// ============================================
// API ENDPOINTS
// ============================================

/**
 * Health check
 */
app.get("/health", (req, res) => {
  res.json({
    status: "OK",
    version: "7.0",
    features: ["text", "bitmap", "pdf"],
    timestamp: new Date().toISOString(),
  });
});

/**
 * POST /print/pdf - In file PDF tr·∫Øng ƒëen
 * Body: {
 *   printerIp: "192.168.1.100",
 *   printerPort: 9100,
 *   pdf: "base64_encoded_pdf_data",
 *   width: 576 (optional, default 576px for 80mm),
 *   dpi: 203 (optional, default 203),
 *   threshold: 128 (optional, 0-255, default 128)
 * }
 */
app.post("/print/pdf", async (req, res) => {
  try {
    const { printerIp, printerPort = 9100, pdf, width = 576, dpi = 203, threshold = 128 } = req.body;

    if (!printerIp || !pdf) {
      return res.status(400).json({
        error: "Missing required fields: printerIp, pdf",
      });
    }

    console.log(`\nüìÑ [PDF Print Request]`);
    console.log(`   Printer: ${printerIp}:${printerPort}`);
    console.log(`   Width: ${width}px, DPI: ${dpi}, Threshold: ${threshold}`);

    // Decode base64 PDF
    const pdfBuffer = Buffer.from(pdf, "base64");
    console.log(`   PDF size: ${(pdfBuffer.length / 1024).toFixed(2)} KB`);

    // Step 1: Convert PDF to PNG
    console.log(`   üîÑ Converting PDF to image...`);
    const imageBuffer = await convertPdfToImage(pdfBuffer, dpi);
    console.log(`   ‚úÖ Image created`);

    // Step 2: Convert to monochrome
    console.log(`   üîÑ Processing image to monochrome...`);
    const { data, width: imgWidth, height: imgHeight } = await convertToMonochrome(
      imageBuffer,
      width,
      threshold
    );
    console.log(`   ‚úÖ Monochrome image: ${imgWidth}x${imgHeight}px`);

    // Step 3: Create ESC/POS commands
    console.log(`   üîÑ Creating ESC/POS bitmap commands...`);
    const escposData = createBitmapCommands(data, imgWidth, imgHeight);
    console.log(`   ‚úÖ Commands created: ${escposData.length} bytes`);

    // Step 4: Send to printer
    console.log(`   üì§ Sending to printer...`);
    await sendToPrinter(printerIp, printerPort, escposData);
    console.log(`   ‚úÖ Print job sent successfully\n`);

    res.json({
      success: true,
      message: "PDF printed successfully",
      details: {
        imageSize: `${imgWidth}x${imgHeight}`,
        dataSize: escposData.length,
      },
    });
  } catch (error) {
    console.error(`   ‚ùå Error: ${error.message}\n`);
    res.status(500).json({
      error: error.message,
      stack: process.env.NODE_ENV === "development" ? error.stack : undefined,
    });
  }
});

/**
 * POST /print/text - In text v·ªõi CP1258
 */
app.post("/print/text", async (req, res) => {
  try {
    const { printerIp, printerPort = 9100, text, encoding = "cp1258" } = req.body;

    if (!printerIp || !text) {
      return res.status(400).json({
        error: "Missing required fields: printerIp, text",
      });
    }

    console.log(`\nüìù [Text Print Request]`);
    console.log(`   Printer: ${printerIp}:${printerPort}`);
    console.log(`   Encoding: ${encoding}`);

    // Build ESC/POS commands
    const commands = [];

    // Initialize
    commands.push(Buffer.from([0x1B, 0x40]));

    // Set code page to CP1258 if requested
    if (encoding === "cp1258") {
      commands.push(Buffer.from([0x1B, 0x74, 0x1E])); // ESC t 30
    }

    // Convert text
    const convertedText = encoding === "cp1258" ? convertToCP1258(text) : text;
    commands.push(Buffer.from(convertedText + "\n\n\n", "binary"));

    // Cut
    commands.push(Buffer.from([0x1D, 0x56, 0x00]));

    const escposData = Buffer.concat(commands);

    // Send to printer
    await sendToPrinter(printerIp, printerPort, escposData);
    console.log(`   ‚úÖ Text printed successfully\n`);

    res.json({
      success: true,
      message: "Text printed successfully",
    });
  } catch (error) {
    console.error(`   ‚ùå Error: ${error.message}\n`);
    res.status(500).json({
      error: error.message,
    });
  }
});

/**
 * POST /print/bitmap - In bitmap t·ª´ canvas
 */
app.post("/print/bitmap", async (req, res) => {
  try {
    const { printerIp, printerPort = 9100, bitmap, width, height, threshold = 128 } = req.body;

    if (!printerIp || !bitmap || !width || !height) {
      return res.status(400).json({
        error: "Missing required fields: printerIp, bitmap, width, height",
      });
    }

    console.log(`\nüñºÔ∏è  [Bitmap Print Request]`);
    console.log(`   Printer: ${printerIp}:${printerPort}`);
    console.log(`   Size: ${width}x${height}px`);

    // Convert base64 bitmap to buffer
    const imageBuffer = Buffer.from(bitmap, "base64");

    // Process image
    const { data, width: imgWidth, height: imgHeight } = await convertToMonochrome(
      imageBuffer,
      width,
      threshold
    );

    // Create ESC/POS commands
    const escposData = createBitmapCommands(data, imgWidth, imgHeight);

    // Send to printer
    await sendToPrinter(printerIp, printerPort, escposData);
    console.log(`   ‚úÖ Bitmap printed successfully\n`);

    res.json({
      success: true,
      message: "Bitmap printed successfully",
    });
  } catch (error) {
    console.error(`   ‚ùå Error: ${error.message}\n`);
    res.status(500).json({
      error: error.message,
    });
  }
});

// ============================================
// START SERVER
// ============================================

app.listen(PORT, () => {
  console.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
  console.log(`‚ïë   XC80 Print Bridge Server v7.0 - PDF SUPPORT                ‚ïë`);
  console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);
  console.log(`üì° Server running on port ${PORT}`);
  console.log(`üåê Endpoints:`);
  console.log(`   GET  /health           - Health check`);
  console.log(`   POST /print/pdf        - Print PDF (black & white)`);
  console.log(`   POST /print/text       - Print text (CP1258)`);
  console.log(`   POST /print/bitmap     - Print bitmap from canvas\n`);
  console.log(`üìã Requirements:`);
  console.log(`   ‚Ä¢ pdftoppm must be installed (poppler-utils)`);
  console.log(`   ‚Ä¢ Ubuntu/Debian: sudo apt-get install poppler-utils`);
  console.log(`   ‚Ä¢ macOS: brew install poppler`);
  console.log(`   ‚Ä¢ Windows: Download poppler from https://blog.alivate.com.au/poppler-windows/\n`);
  console.log(`üöÄ Ready to accept print jobs!`);
  console.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);
});
