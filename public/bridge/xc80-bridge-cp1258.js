/**
 * XC80 Print Bridge Server v6.0 - BITMAP SUPPORT
 * H·ªó tr·ª£ CP1258 (Windows-1258) cho ti·∫øng Vi·ªát c√≥ d·∫•u
 * H·ªó tr·ª£ in BITMAP tr·ª±c ti·∫øp t·ª´ canvas
 * 
 * C√°ch ch·∫°y:
 * npm install express body-parser cors iconv-lite
 * node xc80-bridge-cp1258.js
 */

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const net = require('net');
const iconv = require('iconv-lite');

const app = express();
const PORT = 9100;

// Middleware
app.use(cors());
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.raw({ type: 'application/octet-stream', limit: '10mb' }));

// ESC/POS Constants
const ESC = '\x1B';
const GS = '\x1D';

/**
 * CP1258 Encoding Map (Unicode ‚Üí Windows-1258)
 */
const CP1258_MAP = {
  // Lowercase vowels
  '√†': '\xE0', '√°': '\xE1', '·∫£': '\xE3', '√£': '\xE3', '·∫°': '\xE1',
  '·∫±': '\xE0', '·∫Ø': '\xE1', '·∫≥': '\xE3', '·∫µ': '\xE3', '·∫∑': '\xE1',
  '√®': '\xE8', '√©': '\xE9', '·∫ª': '\xEB', '·∫Ω': '\xEB', '·∫π': '\xE9',
  '√¨': '\xEC', '√≠': '\xED', '·ªâ': '\xEF', 'ƒ©': '\xEF', '·ªã': '\xED',
  '√≤': '\xF2', '√≥': '\xF3', '·ªè': '\xF5', '√µ': '\xF5', '·ªç': '\xF3',
  '√π': '\xF9', '√∫': '\xFA', '·ªß': '\xFC', '≈©': '\xFC', '·ª•': '\xFA',
  '·ª≥': '\xFD', '√Ω': '\xFD', '·ª∑': '\xFF', '·ªπ': '\xFF', '·ªµ': '\xFD',
  
  // Special characters
  'ƒë': '\xF0', 'ƒê': '\xD0',
  
  // Uppercase vowels  
  '√Ä': '\xC0', '√Å': '\xC1', '·∫¢': '\xC3', '√É': '\xC3', '·∫†': '\xC1',
  '√à': '\xC8', '√â': '\xC9', '·∫∫': '\xCB', '·∫º': '\xCB', '·∫∏': '\xC9',
  '√å': '\xCC', '√ç': '\xCD', '·ªà': '\xCF', 'ƒ®': '\xCF', '·ªä': '\xCD',
  '√í': '\xD2', '√ì': '\xD3', '·ªé': '\xD5', '√ï': '\xD5', '·ªå': '\xD3',
  '√ô': '\xD9', '√ö': '\xDA', '·ª¶': '\xDC', '≈®': '\xDC', '·ª§': '\xDA',
  '·ª≤': '\xDD', '√ù': '\xDD', '·ª∂': '\xDF', '·ª∏': '\xDF', '·ª¥': '\xDD'
};

/**
 * Chuy·ªÉn Unicode sang CP1258
 */
function convertToCP1258(text) {
  let result = '';
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    result += CP1258_MAP[char] || char;
  }
  return result;
}

/**
 * B·ªè d·∫•u ti·∫øng Vi·ªát
 */
function removeVietnameseTones(str) {
  const tones = {
    '√†': 'a', '√°': 'a', '·∫£': 'a', '√£': 'a', '·∫°': 'a',
    'ƒÉ': 'a', '·∫±': 'a', '·∫Ø': 'a', '·∫≥': 'a', '·∫µ': 'a', '·∫∑': 'a',
    '√¢': 'a', '·∫ß': 'a', '·∫•': 'a', '·∫©': 'a', '·∫´': 'a', '·∫≠': 'a',
    'ƒë': 'd',
    '√®': 'e', '√©': 'e', '·∫ª': 'e', '·∫Ω': 'e', '·∫π': 'e',
    '√™': 'e', '·ªÅ': 'e', '·∫ø': 'e', '·ªÉ': 'e', '·ªÖ': 'e', '·ªá': 'e',
    '√¨': 'i', '√≠': 'i', '·ªâ': 'i', 'ƒ©': 'i', '·ªã': 'i',
    '√≤': 'o', '√≥': 'o', '·ªè': 'o', '√µ': 'o', '·ªç': 'o',
    '√¥': 'o', '·ªì': 'o', '·ªë': 'o', '·ªï': 'o', '·ªó': 'o', '·ªô': 'o',
    '∆°': 'o', '·ªù': 'o', '·ªõ': 'o', '·ªü': 'o', '·ª°': 'o', '·ª£': 'o',
    '√π': 'u', '√∫': 'u', '·ªß': 'u', '≈©': 'u', '·ª•': 'u',
    '∆∞': 'u', '·ª´': 'u', '·ª©': 'u', '·ª≠': 'u', '·ªØ': 'u', '·ª±': 'u',
    '·ª≥': 'y', '√Ω': 'y', '·ª∑': 'y', '·ªπ': 'y', '·ªµ': 'y',
    '√Ä': 'A', '√Å': 'A', '·∫¢': 'A', '√É': 'A', '·∫†': 'A',
    'ƒÇ': 'A', '·∫∞': 'A', '·∫Æ': 'A', '·∫≤': 'A', '·∫¥': 'A', '·∫∂': 'A',
    '√Ç': 'A', '·∫¶': 'A', '·∫§': 'A', '·∫®': 'A', '·∫™': 'A', '·∫¨': 'A',
    'ƒê': 'D',
    '√à': 'E', '√â': 'E', '·∫∫': 'E', '·∫º': 'E', '·∫∏': 'E',
    '√ä': 'E', '·ªÄ': 'E', '·∫æ': 'E', '·ªÇ': 'E', '·ªÑ': 'E', '·ªÜ': 'E',
    '√å': 'I', '√ç': 'I', '·ªà': 'I', 'ƒ®': 'I', '·ªä': 'I',
    '√í': 'O', '√ì': 'O', '·ªé': 'O', '√ï': 'O', '·ªå': 'O',
    '√î': 'O', '·ªí': 'O', '·ªê': 'O', '·ªî': 'O', '·ªñ': 'O', '·ªò': 'O',
    '∆†': 'O', '·ªú': 'O', '·ªö': 'O', '·ªû': 'O', '·ª†': 'O', '·ª¢': 'O',
    '√ô': 'U', '√ö': 'U', '·ª¶': 'U', '≈®': 'U', '·ª§': 'U',
    '∆Ø': 'U', '·ª™': 'U', '·ª®': 'U', '·ª¨': 'U', '·ªÆ': 'U', '·ª∞': 'U',
    '·ª≤': 'Y', '√ù': 'Y', '·ª∂': 'Y', '·ª∏': 'Y', '·ª¥': 'Y'
  };
  
  return str.split('').map(char => tones[char] || char).join('');
}

/**
 * T·∫°o ESC/POS commands cho TEXT
 */
function buildTextESCPOS(content, options = {}) {
  const {
    mode = 'cp1258',
    align = 'left',
    feeds = 3
  } = options;
  
  const commands = [];
  
  // Initialize
  commands.push(Buffer.from([0x1B, 0x40])); // ESC @
  
  // Set Code Page
  if (mode === 'cp1258') {
    commands.push(Buffer.from([0x1B, 0x74, 0x1E])); // ESC t 30
    content = convertToCP1258(content);
  } else if (mode === 'no-accents') {
    commands.push(Buffer.from([0x1B, 0x74, 0x00])); // ESC t 0
    content = removeVietnameseTones(content);
  }
  
  // Alignment
  const alignCode = { left: 0x00, center: 0x01, right: 0x02 }[align] || 0x00;
  commands.push(Buffer.from([0x1B, 0x61, alignCode]));
  
  // Content
  commands.push(Buffer.from(content, 'binary'));
  
  // Paper feed
  if (feeds > 0) {
    commands.push(Buffer.from([0x1B, 0x64, feeds]));
  }
  
  // Cut paper
  commands.push(Buffer.from([0x1D, 0x56, 0x00]));
  
  return Buffer.concat(commands);
}

/**
 * G·ª≠i data ƒë·∫øn m√°y in
 */
async function sendToPrinter(ip, port, data) {
  return new Promise((resolve, reject) => {
    const client = net.createConnection({ host: ip, port, timeout: 5000 }, () => {
      console.log(`‚úÖ Connected to printer: ${ip}:${port}`);
      
      client.write(data, (err) => {
        if (err) {
          console.error('‚ùå Write error:', err);
          reject(err);
        } else {
          console.log(`‚úÖ Sent ${data.length} bytes to printer`);
          setTimeout(() => {
            client.end();
            resolve({ success: true });
          }, 500);
        }
      });
    });
    
    client.on('error', (err) => {
      console.error('‚ùå Connection error:', err);
      reject(err);
    });
    
    client.on('timeout', () => {
      console.error('‚ùå Connection timeout');
      client.destroy();
      reject(new Error('Connection timeout'));
    });
  });
}

// ============================================================================
// ROUTES
// ============================================================================

/**
 * Health check
 */
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    version: '6.0.0',
    features: ['text', 'bitmap', 'cp1258'],
    timestamp: new Date().toISOString()
  });
});

/**
 * Print TEXT (legacy endpoint)
 */
app.post('/print', async (req, res) => {
  try {
    const { ip, port = 9100, content, options = {} } = req.body;
    
    if (!ip || !content) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: ip, content'
      });
    }
    
    console.log(`üìÑ TEXT Print request: ${ip}:${port}`);
    console.log(`üìù Content length: ${content.length} chars`);
    
    const escposData = buildTextESCPOS(content, options);
    const result = await sendToPrinter(ip, port, escposData);
    
    res.json({
      success: true,
      message: 'Print job sent successfully',
      bytes: escposData.length
    });
    
  } catch (error) {
    console.error('‚ùå Print error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Print BITMAP (new endpoint)
 * Nh·∫≠n base64 encoded ESC/POS bitmap commands
 */
app.post('/print-bitmap', async (req, res) => {
  try {
    const { ip, port = 9100, bitmap } = req.body;
    
    if (!ip || !bitmap) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: ip, bitmap (base64)'
      });
    }
    
    console.log(`üñºÔ∏è BITMAP Print request: ${ip}:${port}`);
    console.log(`üì¶ Bitmap data length: ${bitmap.length} chars (base64)`);
    
    // Decode base64 to binary
    const bitmapData = Buffer.from(bitmap, 'base64');
    console.log(`‚úÖ Decoded to ${bitmapData.length} bytes`);
    
    // Send directly to printer (data already contains ESC/POS commands)
    const result = await sendToPrinter(ip, port, bitmapData);
    
    res.json({
      success: true,
      message: 'Bitmap print job sent successfully',
      bytes: bitmapData.length
    });
    
  } catch (error) {
    console.error('‚ùå Bitmap print error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Print PDF (convert to image then bitmap)
 * Note: Thermal printers don't support PDF directly
 */
app.post('/print-pdf', async (req, res) => {
  try {
    const { ip, port = 9100, pdfBase64 } = req.body;
    
    if (!ip || !pdfBase64) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: ip, pdfBase64'
      });
    }
    
    console.log(`üìÑ PDF Print request: ${ip}:${port}`);
    console.log(`üì¶ PDF data length: ${pdfBase64.length} chars (base64)`);
    
    // Note: XC80 thermal printer doesn't support PDF directly
    // This would require converting PDF ‚Üí Image ‚Üí ESC/POS bitmap
    // For now, return error suggesting browser print dialog instead
    
    return res.status(501).json({
      success: false,
      error: 'PDF printing not yet implemented for thermal printers. Please use browser print dialog instead.'
    });
    
  } catch (error) {
    console.error('‚ùå PDF print error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * Test connection
 */
app.post('/test', async (req, res) => {
  try {
    const { ip, port = 9100 } = req.body;
    
    if (!ip) {
      return res.status(400).json({
        success: false,
        error: 'Missing required field: ip'
      });
    }
    
    console.log(`üîç Testing connection: ${ip}:${port}`);
    
    // Send simple test command (initialize printer)
    const testData = Buffer.from([0x1B, 0x40]); // ESC @
    await sendToPrinter(ip, port, testData);
    
    res.json({
      success: true,
      message: 'Connection test successful',
      printer: `${ip}:${port}`
    });
    
  } catch (error) {
    console.error('‚ùå Test connection error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// START SERVER
// ============================================================================

app.listen(PORT, '0.0.0.0', () => {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë  üñ®Ô∏è  XC80 Print Bridge Server v6.0 - BITMAP SUPPORT  ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log('');
  console.log(`‚úÖ Server running on: http://localhost:${PORT}`);
  console.log('');
  console.log('üì° Available endpoints:');
  console.log('   GET  /health          - Health check');
  console.log('   POST /print           - Print TEXT (CP1258 support)');
  console.log('   POST /print-bitmap    - Print BITMAP (ESC/POS format)');
  console.log('   POST /test            - Test printer connection');
  console.log('');
  console.log('üéØ Features:');
  console.log('   ‚úì Vietnamese CP1258 encoding');
  console.log('   ‚úì Direct bitmap printing');
  console.log('   ‚úì ESC/POS GS v 0 format');
  console.log('   ‚úì Base64 encoded data');
  console.log('');
  console.log('üìñ Example bitmap print request:');
  console.log('   POST http://localhost:9100/print-bitmap');
  console.log('   Body: {');
  console.log('     "ip": "192.168.1.100",');
  console.log('     "port": 9100,');
  console.log('     "bitmap": "<base64-encoded-escpos-data>"');
  console.log('   }');
  console.log('');
  console.log('‚ö° Ready to receive print jobs!');
  console.log('');
});

// Error handling
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
});

process.on('unhandledRejection', (error) => {
  console.error('‚ùå Unhandled Rejection:', error);
});
